#!/bin/bash
# Ensure the script runs with elevated privileges
if [ $EUID -ne 0 ]; then
    echo "Please run this as root!" 
    exit 1
fi

# Define functions for each menu option
fix_and_clean_dnf() {
# File path
dnf_conf="/etc/dnf/dnf.conf"

# Check if dnf.conf exists
if [ ! -f "$dnf_conf" ]; then
    echo "dnf.conf not found."
    exit 1
fi

# Check if the lines already exist, if not, add them
    grep -q '^fastestmirror=true$' "$dnf_conf" || echo 'fastestmirror=true' >> "$dnf_conf"
    grep -q '^max_parallel_downloads=10$' "$dnf_conf" || echo 'max_parallel_downloads=10' >> "$dnf_conf"
    grep -q '^countme=false$' "$dnf_conf" || echo 'countme=false' >> "$dnf_conf"
    grep -q '^defaultyes=True$' "$dnf_conf" || echo 'defaultyes=True' >> "$dnf_conf"

    echo "Checked and updated $DNF_CONF"
    sleep 2
    # Clean cache and upgrade DNF
    dnf clean all
    dnf upgrade -y
    clear
}

check_firmware_update() {
    echo "Check for Firmware update"
    
    if command -v fwupdmgr >/dev/null 2>&1; then
       fwupdmgr get-devices
       fwupdmgr refresh --force
       fwupdmgr get-updates -y && fwupdmgr update -y
    fi
    echo "Press any Key"
    read
    clear
}

install_rpm_fusion() {
    echo "Install RPM Fusion"
    
    fedora_version=$(rpm -E %fedora)
    rpmfusion_free_url="https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-${fedora_version}.noarch.rpm"
    rpmfusion_nonfree_url="https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-${fedora_version}.noarch.rpm"

    dnf install -y --nogpgcheck "$rpmfusion_free_url" "$rpmfusion_nonfree_url"
    dnf install -y rpmfusion-free-appstream-data rpmfusion-nonfree-appstream-data 
    dnf install -y rpmfusion-free-release-tainted rpmfusion-nonfree-release-tainted
    clear
}
install_amd_drivers(){
    dnf swap -y mesa-va-drivers mesa-va-drivers-freeworld
    dnf swap -y mesa-vdpau-drivers mesa-vdpau-drivers-freeworld
    dnf install -y libva-utils
}
install_intel_drivers(){
    dnf install -y intel-media-driver
    dnf install -y  libva-utils
}

install_drivers() {
    # Check if rpmfusion-free and rpmfusion-nonfree repositories are enabled
    free_repo=$(dnf repolist all | grep -i 'rpmfusion-free')
    nonfree_repo=$(dnf repolist all | grep -i 'rpmfusion-nonfree')
    
    if [[ -n "$free_repo" && -n "$nonfree_repo" ]]; then
     while true; do
        CHOICE=$(dialog --clear \
                --title "Video Drivers" \
                --nocancel \
                --menu "Choose an option:" \
                15 60 3 \
                1 "Install Mesa FreeWorld Drivers for AMD" \
                2 "Install Intel Media Driver" \
                3 "Exit" \
                3>&1 1>&2 2>&3)

        clear
        case $CHOICE in
            1) install_amd_drivers ;;
            2) install_intel_drivers ;;
            3) break ;;
            *) echo "Invalid option. Please try again." ;;
        esac
    done
    else
        dialog --msgbox "Please Enable RPM Fusion First" 0 0
        break
    fi
}



install_media_codecs() {
    echo "Install Media Codecs"
    
    free_repo=$(dnf repolist all | grep -i 'rpmfusion-free')
    nonfree_repo=$(dnf repolist all | grep -i 'rpmfusion-nonfree')

    if [[ -n "$free_repo" && -n "$nonfree_repo" ]]; then
        dnf update -y
        dnf install -y gstreamer1-plugins-{bad-\*,good-\*,base} gstreamer1-plugin-openh264 gstreamer1-libav --exclude=gstreamer1-plugins-bad-free-devel
        dnf install -y lame* --exclude=lame-devel
        dnf group upgrade -y --with-optional Multimedia
    else
        dialog --msgbox "Please Enable RPM Fusion First" 0 0
        break
    fi
}

enable_flathub() {
    flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
    dialog --msgbox "Flathub Enabled" 0 0
}

install_google_chrome() {
    dnf install -y fedora-workstation-repositories
    dnf config-manager --set-enabled google-chrome
    dnf -y install google-chrome-stable
    dialog --msgbox "Google Chrome Installed" 0 0
}

install_looking_glass_client() {
            download
            #Build and Install the Looking-Glass-Client
            dnf install cmake gcc gcc-c++ libglvnd-devel fontconfig-devel spice-protocol make nettle-devel \
            pkgconf-pkg-config binutils-devel libXi-devel libXinerama-devel libXcursor-devel \
            libXpresent-devel libxkbcommon-x11-devel wayland-devel wayland-protocols-devel \
            libXScrnSaver-devel libXrandr-devel dejavu-sans-mono-fonts libdecor-devel pipewire-devel libsamplerate-devel pulseaudio-libs-devel libsamplerate-devel -y
            tar -xvzf looking-glass-B6.tar.gz
            dir1=$(pwd)
            cd looking-glass-B6
            mkdir client/build
            cd client/build
            cmake ..
            make install
            cd $dir1
            rm -rf looking-glass-B6
            VIRT_USER=`logname`
                   

          # Prompt the user whether to manually edit the username using dialog
            USER_YN=$(dialog --stdout --defaultno --yesno "$VIRT_USER Will be Set to use Looking glass, Do you need to manually edit the username?" 0 0)

            # If the user chooses yes, prompt for a new username using dialog
            if [ "$USER_YN" = "0" ]; then
                USER_YN='n'
            while [ "$USER_YN" = "n" ]; do
                VIRT_USER=$(dialog --stdout --inputbox "Enter the new username:" 0 0)
                USER_YN=$(dialog --stdout --yesno "Is $VIRT_USER correct?" 0 0)
            done
            fi

            # Display the selected username
            dialog --infobox "User $VIRT_USER  has been Selected" 0 0
            
                    
            touch /dev/shm/looking-glass && chown $VIRT_USER:kvm /dev/shm/looking-glass && chmod 660 /dev/shm/looking-glass
            shm=""
            shm=("f /dev/shm/looking-glass 0660 $VIRT_USER kvm -")
            echo $shm > /etc/tmpfiles.d/10-looking-glass.conf
            
            #Set SELINUX permisions
            clear
            echo "Setting SELINUX permisions"
            ausearch -c 'qemu-system-x86' --raw | audit2allow -M my-qemusystemx86 > /dev/null
            semodule -X 300 -i my-qemusystemx86.pp 
            setsebool -P domain_can_mmap_files 1
            clear
            
}
check_grub_cmdline() {
    # Read the current GRUB_CMDLINE_LINUX line from /etc/default/grub
    current_line=$(grep "^GRUB_CMDLINE_LINUX=" /etc/default/grub)

    # Extract the content within the quotes
    current_content=$(echo "$current_line" | sed 's/GRUB_CMDLINE_LINUX="//;s/"$//')

    # Show the current GRUB_CMDLINE_LINUX line
    echo "Current GRUB_CMDLINE_LINUX line:"
    echo "$current_line"

    # Ask for confirmation to replace the line
    read -p "Its best to replace it ,Do you want to replace it? (y/n): " choice
    case "$choice" in
        y|Y )
            # Replace the content within the quotes
            new_content="rhgb quiet"
            # Replace the line in the file
            sed -i "s/^GRUB_CMDLINE_LINUX=\"$current_content\"/GRUB_CMDLINE_LINUX=\"$new_content\"/" /etc/default/grub
            ;;
        n|N )
            echo "No changes made. You Will Option to Manual Edit Latter"
            ;;
        * )
            echo "Invalid choice. No changes made. ***** WARNING *****"
            ;;
    esac
}

# Function to update GRUB_TIMEOUT in /etc/default/grub
update_grub_timeout() {
    local new_timeout
    local grub_file="/etc/default/grub"

    # Prompt the user for the new GRUB_TIMEOUT value using dialog
    new_timeout=$(dialog --inputbox "Enter the new GRUB_TIMEOUT value: " 8 40 3>&1 1>&2 2>&3 3>&-)

    # Validate the input (ensure it's a non-negative integer)
    if [[ $new_timeout =~ ^[0-9]+$ ]]; then
        # Check if the grub file exists
        if [[ ! -f $grub_file ]]; then
            echo "Error: $grub_file does not exist."
            return 1
        fi

        # Backup the current grub file
        cp $grub_file ${grub_file}.bak

        # Update the GRUB_TIMEOUT value
        sed -i "s/^GRUB_TIMEOUT=.*/GRUB_TIMEOUT=${new_timeout}/" $grub_file

        # Inform the user of the change
        dialog --msgbox "GRUB_TIMEOUT set to ${new_timeout} in ${grub_file}\n\nGRUB configuration updated." 8 50
        clear
        # Update GRUB configuration
        grub2-mkconfig -o /boot/grub2/grub.cfg
        grub2-mkconfig -o /boot/efi/EFI/fedora/grub.cfg
    else
        dialog --msgbox "Error: Please enter a valid non-negative integer." 8 50
    fi
}

# Function to ask yes/no questions
ask_yes_no() {
    while true; do
        read -p "$1 (y/n): " yn
        case $yn in
            [Yy]* ) return 0;;
            [Nn]* ) return 1;;
            * ) echo "Please answer yes (y) or no (n).";;
        esac
    done
}

# Function to configure the system based on user input
configure_system() {
    # Check if INTEL is set to 1
    if [ "$INTEL" = "1" ]; then
        # Ask if Intel GVT support is required
        if ask_yes_no "Do you require Intel GVT support?"; then
            echo "Intel GVT support will be configured."
            # Add the code to configure Intel GVT support here
            #sets GVT surport to yes
            GVT="1"
        else
            #Sets GVT Surport to no
            GVT="0"
            echo "Intel GVT support will not be configured."
        fi
    fi
    # Ask if user wants to passthrough a video and audio device
    if ask_yes_no "Would you like to passthrough a video and audio device?"; then
        echo "Video and audio passthrough will be configured."
        # Add the code to configure video and audio passthrough here
        # Example: echo "video_audio_passthrough_config" >> /etc/config_file
        select_device "VGA"
        vga_device_id="${selected_device_id}"
        vga_device_line="${selected_device_line}"
        # Call the function for selecting HD device
        select_device "Audio"

        # Store the selected HD device name and ID in variables
        hd_device_id="${selected_device_id}"
        hd_device_line="${selected_device_line}"

        parsed_VIDEO=$(echo "$vga_device_id" | tr -d '[]')
        parsed_AUDIO=$(echo "$hd_device_id" | tr -d '[]')

        #echo "VGA device line: $vga_device_line"
        #echo "HD device line: $hd_device_line"
        echo "Selected VGA device: $parsed_VIDEO"
        echo "Selected HD device: $parsed_AUDIO"
        #sets passthrough to yes
        pass="1"

    else
        echo "Video and audio passthrough will not be configured."
        #sets passthrough to no
        pass="0"
    fi

    # Ask if user wants to blacklist nouveau
    if ask_yes_no "Would you like to blacklist nouveau?"; then
        echo "Nouveau will be blacklisted."
        # Add the code to blacklist nouveau here
        # blacklist yes
        Nouveau="1"
    else
        #blacklist no
        Nouveau="0"
        echo "Nouveau will not be blacklisted."
    fi

    echo "Configuration complete."
}
configure_intel_iommu() {
    #asks what user wants to do
    configure_system
    # Check each variable and append corresponding strings to the result
    IOMMU=""
    IOMMU="intel_iommu=on"
    if [ "$GVT" -eq 1 ]; then
        intel1="i915.enable_gvt=1 i915.enable_guc=0"
        IOMMU="$IOMMU $intel1"
    fi

    if [ "$pass" -eq 1 ]; then
        intel2="pcie_aspm=off rd.driver.pre=vfio-pci vfio-pci.ids=$parsed_VIDEO,$parsed_AUDIO"
        IOMMU="$IOMMU $intel2"
    fi

    if [ "$Nouveau" -eq 1 ]; then
        intel3="rd.driver.blacklist=nouveau"
        IOMMU="$IOMMU $intel3"
    fi
  
}

#get Audio and Video Passthrough ID'S
select_device() {
    local device_type=$1
    local devices=$(lspci -nnk | grep -i "$device_type" | grep -oP '.*\[([0-9a-fA-F]{4}):([0-9a-fA-F]{4})\].*')

    if [ -z "$devices" ]; then
        echo "No $device_type devices found."
        return 1
    fi

    echo "Available $device_type devices:"
    local index=0
    local device_ids=()
    local device_lines=()
    while read -r device; do
        index=$((index+1))
        device_id=$(echo "$device" | grep -oP '\[([0-9a-fA-F]{4}):([0-9a-fA-F]{4})\]')
        device_ids+=("$device_id")
        device_lines+=("$device")
        echo "$index. $device"
    done <<< "$devices"

    read -p "Enter the number corresponding to your $device_type device: " choice
    if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
        echo "Invalid input. Please enter a number."
        return 1
    fi

    if [ "$choice" -lt 1 ] || [ "$choice" -gt "${#device_ids[@]}" ]; then
        echo "Invalid selection. Please enter a valid number."
        return 1
    fi

    selected_device_id="${device_ids[$((choice-1))]}"
    selected_device_line="${device_lines[$((choice-1))]}"
    clear
 }

configure_amd_iommu() {
   configure_system
    # Check each variable and append corresponding strings to the result
    IOMMU=""
    IOMMU="amd_iommu=on"

    if [ "$pass" -eq 1 ]; then
        AMD1="pcie_aspm=off rd.driver.pre=vfio-pci vfio-pci.ids=$parsed_VIDEO,$parsed_AUDIO"
        IOMMU="$IOMMU $AMD1"
    fi

    if [ "$Nouveau" -eq 1 ]; then
        AMD2="rd.driver.blacklist=nouveau"
        IOMMU="$IOMMU $AMD2"
    fi
}

DETECT_CPU(){
            ####Detecting CPU
            CPU=$(lscpu | grep GenuineIntel | rev | cut -d ' ' -f 1 | rev )
            INTEL="0"
            if [ "$CPU" = "GenuineIntel" ]
	        then
	            INTEL="1" 
            else
                INTEL="0"
            fi
}

IOMMU_SETUP(){
            clear
            #asks if need to delete vfio-pci-override-vga.sh
            if [ -e /sbin/vfio-pci-override-vga.sh ]; then 
            read -p "Would you like to delete /sbin/vfio-pci-override-vga.sh? (y/n): " choice

            # Check the user's input
            if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
            # Attempt to delete the file
            if rm /sbin/vfio-pci-override-vga.sh; then
                echo "File deleted successfully."
            else
                echo "Failed to delete the file."
            fi
            else
                echo "File deletion canceled."
            fi
            fi
            check_grub_cmdline
            ##Creating backups
            echo  "Creating backups"

            cat /etc/default/grub > grub_backup

            if [ -a /etc/modprobe.d/local.conf ]
            then 
                mv /etc/modprobe.d/local.conf modprobe.backup
            fi

            if [ -a /etc/dracut.conf.d/local.conf ]
	        then 
	                mv /etc/dracut.conf.d/local.conf local.conf.backup
            fi

            cp /etc/default/grub new_grub
            # Dectect cpu type
            DETECT_CPU
            if [ "$INTEL" -eq 1 ]; then
                configure_intel_iommu
            else
                configure_amd_iommu
            fi
             #Putting together new grub string
                OLD_OPTIONS=`cat new_grub | grep GRUB_CMDLINE_LINUX | cut -d '"' -f 1,2`

                NEW_OPTIONS="$OLD_OPTIONS $IOMMU\""
                echo $NEW_OPTIONS

                #Rebuilding grub 
                sed -i -e "s|^GRUB_CMDLINE_LINUX.*|${NEW_OPTIONS}|" new_grub

                #User verification of new grub and prompt to manually edit it
                echo 
                echo "Grub was modified to look like this: "
                echo `cat new_grub | grep "GRUB_CMDLINE_LINUX"`
                echo 
                echo "Do you want to edit it? y/n"
                read YN

                if [ $YN = y ]
                then
                    nano new_grub
                fi

                cp new_grub /etc/default/grub

               # Check if passthrough is required
                if [ "$pass" = "1" ]; then
                # Copying necessary scripts
                    echo "Getting GPU passthrough scripts ready"

                    cp vfio-pci-override-vga.sh /sbin/vfio-pci-override-vga.sh

                    chmod 755 /sbin/vfio-pci-override-vga.sh

                    echo "install vfio-pci /sbin/vfio-pci-override-vga.sh" > /etc/modprobe.d/local.conf

                    cp local.conf /etc/dracut.conf.d/local.conf
                fi
                
                echo "Updating grub and generating initramfs"

                grub2-mkconfig -o /boot/grub2/grub.cfg
                grub2-mkconfig -o /boot/efi/EFI/fedora/grub.cfg
                dracut -f --kver `uname -r`
}
#Intel GVT surport
enable_intel_gvt_service() {
    clear
    echo "=========================================="
    echo "|   Enable INTEL GVT SERVICE             |"
    echo "=========================================="
    modprobe kvmgt mdev vfio-iommu-type1
    GPU=""
    MAX=0
    UUID=$(uuidgen)
    VIRT_USER=$(logname)

    # Finding the Intel GPU and choosing the one with the highest weight value
    for i in $(find /sys/devices/pci* -name 'mdev_supported_types'); do
        for y in $(find "$i" -name 'description'); do
            WEIGHT=$(cat "$y" | tail -1 | cut -d ' ' -f 2)
            if [ "$WEIGHT" -gt "$MAX" ]; then
                GPU=$(echo "$y" | cut -d '/' -f 1-7)
                MAX="$WEIGHT"
            fi
        done
    done

    if [ -n "$GPU" ]; then
        echo "<hostdev mode='subsystem' type='mdev' managed='no' model='vfio-pci' display='off'>" > virsh.txt
        echo "<source>" >> virsh.txt
        echo "<address uuid=\"$UUID\"/>" >> virsh.txt
        echo "</source>" >> virsh.txt
        echo "</hostdev>" >> virsh.txt

        # Initializing virtual GPU on every startup
        echo "modprobe kvmgt mdev vfio-iommu-type1" >> gvt_pe.sh
        echo "echo $UUID > $GPU/create" >> gvt_pe.sh

        # Create a systemd service to initialize the GPU on startup
        cp gvt_pe.service /etc/systemd/system/gvt_pe.service
        chmod 644 /etc/systemd/system/gvt_pe.service

        mv gvt_pe.sh /usr/bin/gvt_pe.sh
        chmod +x /usr/bin/gvt_pe.sh
        systemctl enable gvt_pe.service
        systemctl start gvt_pe.service

        chown "$VIRT_USER" virsh.txt
    else
        echo "No Intel GPU found with mdev_supported_types"
    fi
    sleep 5
}
VIRTMAN(){
    clear
    echo "=========================================="
    echo "|   Installing Virtualization Software   |"
    echo "=========================================="
    dnf install qemu qemu-img nano -y
    dnf groupinstall "Virtualization" -y
}

install_virtualization() {
    # Virtmanager / GPU Passthrough Menu

    while true; do
        CHOICE=$(dialog --clear \
                --title "Virtualization" \
                --nocancel \
                --menu "Choose an option:" \
                15 60 5 \
                1 "Install Virtualization Software" \
                2 "Enable IOMMU And Update Grub" \
                3 "Installing Looking-Glass-Client" \
                4 "Enabling Intel GVT Service" \
                5 "Run Virtmanager as Non Root" \
                B "Back" \
                3>&1 1>&2 2>&3)

        clear
        case $CHOICE in
            1) VIRTMAN ;;
            2) IOMMU_SETUP ;;
            3) install_looking_glass_client ;;
            4) enable_intel_gvt_service ;;
            5) virtman_noroot ;;
            B) break ;;
            *) echo "Invalid option. Please try again." ;;
        esac
    done
}


setup_wifi_nfs_shares() {
    # Function to scan for available Wi-Fi networks and select one
    scan_and_select_wifi() {
        echo "Scanning for available Wi-Fi networks..."
        AVAILABLE_SSIDS=$(nmcli -t -f SSID dev wifi | sort -u)

        if [ -z "$AVAILABLE_SSIDS" ]; then
            echo "No Wi-Fi networks found. Exiting..."
            sleep 5
            exit 1
        fi

        echo "Available Wi-Fi networks:"
        IFS=$'\n'
        select SSID in $AVAILABLE_SSIDS; do
            if [ -n "$SSID" ]; then
                WIFI_SSID="$SSID"
                break
            else
                echo "Invalid selection. Please try again."
            fi
        done
        unset IFS

        echo "Selected Wi-Fi SSID: $WIFI_SSID"
    }

    # Function to update the nfs1.sh script
    update_nfs_script() {
        local wifi_ssid="$1"
        local remote_server="$2"
        local nfs_shares=("${!3}")
        local mount_points=("${!4}")
        local script_path="nfs1.sh"

        if [ -z "$wifi_ssid" ] || [ -z "$remote_server" ]; then
            echo "Error: Wi-Fi SSID or remote server IP is null or empty." >&2
            return 1
        fi

        # Temporary file to store the new content
        local temp_script="${script_path}.tmp"

        # Read the existing content of the nfs1.sh script, excluding any previous variable definitions
        local existing_content=$(grep -vE '^WIFI_SSID=|^REMOTE_SERVER=|^REMOTESHARE_|^LOCALMOUNT_' "$script_path")

        # Write the new variables at the top of the temporary script
        {   echo "#!/bin/bash"
            echo "num_shares=\"$num_shares\""
            echo "WIFI_SSID=\"$wifi_ssid\""
            echo "REMOTE_SERVER=\"$remote_server\""
            for (( j=0; j<${#nfs_shares[@]}; j++ )); do
                echo "REMOTESHARE_$((j+1))=\"${nfs_shares[j]}\""
                echo "LOCALMOUNT_$((j+1))=\"${mount_points[j]}\""
            done
            # Append the rest of the original script
            echo "$existing_content"
        } > "$temp_script"

        mv "$temp_script" "$script_path"
    }

    # Main function to handle Wi-Fi NFS Shares setup
    wifi_nfs_shares() {
        echo "Enable Wi-Fi NFS Shares"
        clear # Clear the screen

        # Scan and select Wi-Fi
        scan_and_select_wifi

        # Prompt the user for the number of NFS shares to add
        read -p "How many NFS shares would you like to add? " num_shares
        read -p "Enter IP of Server (e.g., 10.0.0.10): " REMOTE_SERVER

        nfs_shares=()
        mount_points=()

        # Loop through the number of shares and prompt the user for each share
        for (( i=1; i<=num_shares; i++ )); do
            read -p "Enter the NFS share #$i (e.g., server:/path): " nfs_share
            read -p "Enter the mount point #$i (e.g., /mnt/nfs): " mount_point

            # Create the mount point directory if it doesn't exist
            if [ ! -d "${mount_point}" ]; then
                mkdir -p "${mount_point}"
                echo "Created mount point directory ${mount_point}"
            else
                echo "Mount point directory ${mount_point} already exists"
            fi

            nfs_shares+=("$nfs_share")
            mount_points+=("$mount_point")
        done

        # Update the nfs1.sh script with the new values
        update_nfs_script "$WIFI_SSID" "$REMOTE_SERVER" nfs_shares[@] mount_points[@]

        echo "All specified NFS shares have been added to the nfs1.sh script."

        # Message indicating that Wi-Fi shares will be active on the next reboot
        dialog --msgbox "Wi-Fi Shares Active on Next Reboot" 0 0

        sleep 2
        # Install Service
        cp nfs-start.service /etc/systemd/system/
        cp nfs1.sh /usr/bin/
        chmod +x /usr/bin/nfs1.sh
        systemctl enable nfs-start.service
        dialog --msgbox "Wifi Shares Active on Next Reboot" 0 0
    }

    # Call the main function
    wifi_nfs_shares
}

nfs_shares_via_fstab() {
    echo "NFS Shares Via FSTAB (Wired Only)"
     # Connect NFS Shares VIA FSTAB
            clear # clear screen
            echo "NFS Shares Via FSTAB ( WIRED ONLY )"
            add_to_fstab() {
                local nfs_share=$1
                local mount_point=$2
                local options="rw,sync,hard,intr,rsize=8192,wsize=8192,timeo=14"

                # Backup /etc/fstab before making changes (only once)
                if [ ! -f /etc/fstab.bak ]; then
                    cp /etc/fstab /etc/fstab.bak
                fi

                # Append the NFS entry to the end of /etc/fstab
                echo "${nfs_share} ${mount_point} nfs ${options} 0 0" >> /etc/fstab

                echo "Added ${nfs_share} to /etc/fstab"
            }

            # Prompt the user for the number of shares to add
            read -p "How many NFS shares would you like to add? " num_shares

            for (( i=1; i<=num_shares; i++ )); do
            # Prompt the user for the NFS share and mount point
            read -p "Enter the NFS share #$i (e.g., server:/path): " nfs_share
            read -p "Enter the mount point #$i (e.g., /mnt/nfs): " mount_point

            # Create the mount point directory if it doesn't exist
            if [ ! -d "${mount_point}" ]; then
                mkdir -p "${mount_point}"
                echo "Created mount point directory ${mount_point}"
            else
                echo "Mount point directory ${mount_point} already exists"
            fi

            # Add the NFS entry to /etc/fstab
            add_to_fstab "${nfs_share}" "${mount_point}"
            done

            # Mount all NFS shares
            mount -a

            echo "All specified NFS shares have been mounted."
}
#Downloads looking-glass tar file
download() {
    filename="looking-glass-B6.tar.gz"
    url1="https://looking-glass.io/artifact/stable/source/"
    USER1=$(logname)

    # Function to detect available browser
    detect_browser() {
        if command -v chromium-browser &> /dev/null; then
            echo "chromium-browser"
        elif command -v google-chrome &> /dev/null; then
            echo "google-chrome"
        elif command -v firefox &> /dev/null; then
            echo "firefox"
        else
            echo "none"
        fi
    }

    browser=$(detect_browser)

    if [[ "$browser" == "none" ]]; then
        echo "No supported browsers found. Please install Chromium, Google Chrome, or Firefox."
        exit 1
    fi

    if [[ -f "$filename" ]]; then
        echo "File exists"
    else
        echo "Downloading $filename using $browser..."

        # Open the URL in the default web browser as the normal user
        runuser -u $USER1 -- $browser "$url1" &> /dev/null &

        # Wait for the browser to open and download the file
        sleep 5
        
        # Use xdotool to simulate the download action if needed (depends on the website behavior)
        # Example for Firefox:
        if [[ "$browser" == "firefox" ]]; then
            window_id=$(xdotool search --onlyvisible --name "Mozilla Firefox")
            xdotool windowactivate $window_id
            xdotool key --delay 200 Return
        fi

        # Wait for the user to download the file
        while [ ! -f "/home/$USER1/Downloads/$filename" ]; do
            echo "Waiting for $filename to be downloaded..."
            sleep 5
        done

        echo "$filename found in Downloads directory."
        echo "Moving $filename to the current directory..."
        mv "/home/$USER1/Downloads/$filename" .

        if [[ -f "$filename" ]]; then
            echo "$filename moved successfully."
        else
            echo "Failed to move $filename."
        fi
    fi
}

nfs_setup(){
  while true; do
        CHOICE=$(dialog --clear \
                --title "NFS Share Setup" \
                --nocancel \
                --menu "Choose an option:" \
                15 60 5 \
                1 "WIFI NFS Shares" \
                2 "NFS Shares Via FSTAB ( WIRED ONLY )" \
                B "Back" \
                3>&1 1>&2 2>&3)

        clear
        case $CHOICE in
            1) setup_wifi_nfs_shares ;;
            2) nfs_shares_via_fstab ;;
            B) break ;;
            *) echo "Invalid option. Please try again." ;;
        esac
    done
}
FIX_GRUB(){
        #Fix Fedora Grub Boot Screen
        GRUB_FILE="/etc/default/grub"
        SEARCH_LINE='GRUB_TERMINAL_OUTPUT="console"'
        COMMENTED_LINE='#GRUB_TERMINAL_OUTPUT="console"'
        THEME_LINE='GRUB_THEME="/boot/grub2/theme/fedora/theme.txt"'

        # Check if the GRUB file exists
        if [[ ! -f "$GRUB_FILE" ]]; then
            echo "Error: $GRUB_FILE does not exist."
            exit 1
        fi

        # Use sed to comment out the search line and add the theme line
        if grep -q "^$SEARCH_LINE" "$GRUB_FILE"; then
        # Create a backup of the original file
            cp "$GRUB_FILE" "${GRUB_FILE}.bak"
    
        # Use sed to perform the required changes
            sed -i "s|^$SEARCH_LINE|$COMMENTED_LINE\n$THEME_LINE|" "$GRUB_FILE"
            echo "Updated $GRUB_FILE successfully."
        else
            echo "Line $SEARCH_LINE not found in $GRUB_FILE."
        fi
        # Source and destination directories
        SOURCE_DIR="theme"
        DEST_DIR="/boot/grub2/theme"
            su -c "mkdir /boot/grub2/theme" root
            sleep 10
        #Copy the directory and all its contents
            su -c "cp -r "$SOURCE_DIR"/* "$DEST_DIR"" root
            echo "Directory $SOURCE_DIR copied to $DEST_DIR successfully."
            sleep 5
            grub2-mkconfig -o /boot/grub2/grub.cfg
            grub2-mkconfig -o /boot/efi/EFI/fedora/grub.cfg
}
FIX_KDE_SPLASH(){
            #Fixs Fedora KDE Default Splash Screen to Match Fedora Logo
            USER2=$(logname)
            USER_HOME="/home/$USER2/.config"
            TAR_FILE="FedoraMinimal.tar.gz"
            SOURCE_DIR="FedoraMinimal"
            DEST_DIR="/home/$USER2/.local/share/plasma/look-and-feel/$SOURCE_DIR"

            # Extract the tar.gz file
            echo "Extracting $TAR_FILE..."
            tar -xzf "$TAR_FILE" 2>/dev/null
            if [ $? -ne 0 ]; then
                echo "Error extracting $TAR_FILE."
                exit 1
            fi

            # Ensure the source directory was extracted
            if [ ! -d "$SOURCE_DIR" ]; then
                echo "Source directory $SOURCE_DIR not found after extraction."
                exit 1
            fi

            # Create the destination directory
            echo "Creating destination directory $DEST_DIR..."
            runuser -u "$USER2" -- mkdir -p "$DEST_DIR"
            if [ $? -ne 0 ]; then
                echo "Error creating destination directory $DEST_DIR."
                exit 1
            fi

            # Copy the files
            echo "Copying files from $SOURCE_DIR to $DEST_DIR..."
            runuser -u "$USER2" -- cp -r "$SOURCE_DIR"/* "$DEST_DIR"
            if [ $? -ne 0 ]; then
                echo "Error copying files to $DEST_DIR."
                exit 1
            fi

            echo "Files copied from $SOURCE_DIR to $DEST_DIR successfully."

            # Define the target file
            FILE="$USER_HOME/ksplashrc"

            # Write the specified lines to the ksplashrc file
            echo -e "[KSplash]\nTheme=FedoraMinimal" > "$FILE"
            # set permissions on config
            chown $USER2:$USER2 $FILE
            # Print a success message
            echo "Fedora KDE Splash Screen Theme Fixed."

            # Pause to give user time to read the final message
            sleep 5
}
fedora_theme_fix() {
  while true; do
        CHOICE=$(dialog --clear \
                --title "Theme Fixes" \
                --nocancel \
                --menu "Choose an option:" \
                15 60 5 \
                1 "Fix Fedora grub boot screen" \
                2 "Fix Fedora Default KDE Splash" \
                3 "Change Grub Timeout" \
                4 "Change Host Name" \
                5 "Install Jetbrains mono font" \
                6 "Microsoft core Fonts" \
                B "Back" \
                3>&1 1>&2 2>&3)

        clear
        case $CHOICE in
            1) FIX_GRUB ;;
            2) FIX_KDE_SPLASH ;;
            3) update_grub_timeout ;;
            4) CH_HOSTNAME;;
            5) install_nerd_fonts;;
            6) install_microsoft_core_fonts;;
            B) break ;;
            *) echo "Invalid option. Please try again." ;;
        esac
    done
        
}
#Run Virtmaner as non root
virtman_noroot(){
     # Check if the file exists
    conf_file="/etc/libvirt/libvirtd.conf"
    if [ -f "$conf_file" ]; then
        # Uncomment specific lines
        sed -i '/^#unix_sock_group/s/^#//' "$conf_file"
        sed -i '/^#unix_sock_rw_perms/s/^#//' "$conf_file"

        # Verify changes
        echo "Changes made to $conf_file:"
        grep -E '^unix_sock_group|^unix_sock_rw_perms' "$conf_file"
    else
        echo "$conf_file not found."
        return 1
    fi

   # Check if libvirt group exists
    if ! getent group | grep -q "^libvirt:"; then
        dialog --msgbox "libvirt group does not exist." 0 0
        return 1
    fi

    # Check if the current user is already in the libvirt group
    if groups "$(logname)" | grep -q '\blibvirt\b'; then
         dialog --msgbox "Current user is already in the libvirt group." 0 0
         return 1
    else
        # Add the current user to the libvirt group
        usermod -a -G libvirt "$(logname)"
        dialog --msgbox "Added $(logname) to the libvirt group." 0 0
    fi

    # Activate changes by switching to the libvirt group
    newgrp libvirt

    # Restart or start libvirtd service
    if systemctl is-active --quiet libvirtd.service; then
        echo "Restarting libvirtd service..."
        systemctl restart libvirtd.service
    else
        echo "Starting libvirtd service..."
        systemctl start libvirtd.service
    fi
    dialog --msgbox "Virtmnger as Non Root Active" 0 0
    return 1
}

CH_HOSTNAME() {
    # Capture user input for the hostname
    hostname=$(dialog --inputbox "Enter new hostname:" 0 0 3>&1 1>&2 2>&3 3>&-)

    # Check if the user pressed Cancel or provided an empty input
    if [ $? -eq 0 ] && [ -n "$hostname" ]; then
        # Set the hostname
        hostnamectl set-hostname "$hostname"

        # Display a message box with the new hostname
        dialog --msgbox "Hostname set to $hostname" 0 0
    else
        dialog --msgbox "Hostname not set or input cancelled" 0 0
    fi
}
execsh(){
    # Iterate over all .sh files in the current directory
    for file in *.sh; do
    if [ -f "$file" ]; then
        # Add executable permission
        chmod +x "$file"
    fi
    echo "files mark as execuctable"
done
}

install_nerd_fonts() {
  # Variables
  URL="https://github.com/ryanoasis/nerd-fonts/releases/download/v3.2.1/JetBrainsMono.zip"
  ZIP_FILE="JetBrainsMono.zip"
  EXTRACT_DIR="JetBrainsMono"
  FONT_DIR="/usr/share/fonts/$EXTRACT_DIR"
  LOG_FILE="install_nerd_fonts.log"

  # Logging function
  log() {
    echo "$(date +"%Y-%m-%d %T") - $1" | tee -a $LOG_FILE
  }

  # Start installation
  log "Starting installation of Nerd Fonts"

  # Download the ZIP file
  log "Downloading $URL"
  wget -O $ZIP_FILE $URL
  if [ $? -ne 0 ]; then
    log "Failed to download $URL"
    exit 1
  fi

  # Extract the ZIP file
  log "Extracting $ZIP_FILE"
  unzip $ZIP_FILE -d $EXTRACT_DIR
  if [ $? -ne 0 ]; then
    log "Failed to extract $ZIP_FILE"
    exit 1
  fi

  # Check if destination directory exists, if not, create it
  if [ ! -d "$FONT_DIR" ]; then
    log "Destination directory $FONT_DIR does not exist. Creating it."
    mkdir -p $FONT_DIR
    if [ $? -ne 0 ]; then
      log "Failed to create directory $FONT_DIR"
      exit 1
    fi
  fi

  # Copy the extracted files to the destination directory
  log "Copying extracted files to $FONT_DIR"
  cp -r $EXTRACT_DIR/* $FONT_DIR
  if [ $? -ne 0 ]; then
    log "Failed to copy extracted files to $FONT_DIR"
    exit 1
  fi

  # Change the ownership to root
  log "Changing ownership of $FONT_DIR to root"
  chown -R root: $FONT_DIR
  if [ $? -ne 0 ]; then
    log "Failed to change ownership of $FONT_DIR"
    exit 1
  fi

  # Change the permissions to 644 for files
  log "Changing permissions of files in $FONT_DIR to 644"
  find $FONT_DIR -type f -exec chmod 644 {} \;
  if [ $? -ne 0 ]; then
    log "Failed to change file permissions in $FONT_DIR"
    exit 1
  fi

  # Apply restorecon to the folder
  log "Applying restorecon to $FONT_DIR"
  restorecon -vFr $FONT_DIR
  if [ $? -ne 0 ]; then
    log "Failed to apply restorecon to $FONT_DIR"
    exit 1
  fi

  # Clean up
  log "Cleaning up"
  rm -rf $ZIP_FILE $EXTRACT_DIR
  if [ $? -ne 0 ]; then
    log "Failed to remove $ZIP_FILE or $EXTRACT_DIR"
    exit 1
  fi
    sleep 20
  log "Installation of Nerd Fonts completed successfully"
}
install_microsoft_core_fonts() {
  # Update and install necessary packages
  sudo dnf upgrade --refresh -y
  sudo dnf install curl cabextract xorg-x11-font-utils fontconfig -y
  # Install Microsoft Core Fonts
  
  sudo rpm -i https://downloads.sourceforge.net/project/mscorefonts2/rpms/msttcore-fonts-installer-2.6-1.noarch.rpm
  echo "Installation of Microsoft Core Fonts completed successfully"
}